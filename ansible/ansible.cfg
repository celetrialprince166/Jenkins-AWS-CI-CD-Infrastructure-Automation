# ============================================================================
# ANSIBLE CONFIGURATION FILE
# ============================================================================
# PURPOSE: Configure how Ansible behaves when running playbooks
# LOCATION: This file must be in the ansible/ directory (or project root)
# DOCS: https://docs.ansible.com/ansible/latest/reference_appendices/config.html
# ============================================================================

# ----------------------------------------------------------------------------
# [defaults] - General Ansible settings
# ----------------------------------------------------------------------------
# This section controls Ansible's default behavior for all operations
# ----------------------------------------------------------------------------
[defaults]

# INVENTORY
# ---------
# WHERE: Points to our inventory file (list of servers to manage)
# WHY: Ansible needs to know which servers to connect to
# NOTE: For Packer builds, we use a dynamic inventory, but this is the default
inventory = inventory/hosts.ini

# ROLES PATH
# ----------
# WHERE: Directory containing our reusable roles
# WHY: Ansible looks here when a playbook says "roles: [java, jenkins-controller]"
# STRUCTURE: roles/java/tasks/main.yml, roles/jenkins-controller/tasks/main.yml, etc.
# NOTE: Path is relative to ansible.cfg location (ansible/ directory)
#       If you get "role not found" errors, set ANSIBLE_ROLES_PATH environment variable:
#       export ANSIBLE_ROLES_PATH=$(pwd)/roles
roles_path = roles

# REMOTE USER
# -----------
# WHO: The SSH user Ansible uses to connect to servers
# WHY: Ubuntu AMIs use 'ubuntu' as the default user
# NOTE: Amazon Linux uses 'ec2-user', CentOS uses 'centos'
remote_user = ubuntu

# HOST KEY CHECKING
# -----------------
# WHAT: Whether to verify SSH host keys
# WHY: Set to False for automation - new EC2 instances have unknown host keys
# SECURITY: In production, consider using known_hosts file instead
# WARNING: Disabling this is a security trade-off for automation convenience
host_key_checking = False

# RETRY FILES
# -----------
# WHAT: Whether to create .retry files when playbooks fail
# WHY: False keeps our directory clean - we use CI/CD for retries instead
# NOTE: .retry files list failed hosts for re-running
retry_files_enabled = False

# TIMEOUT
# -------
# WHAT: SSH connection timeout in seconds
# WHY: 30 seconds is enough for most connections, prevents hanging forever
# INCREASE: If connecting to slow/distant servers, increase this
timeout = 30

# GATHERING
# ---------
# WHAT: When to collect facts about remote systems
# OPTIONS: implicit (always), explicit (only when requested), smart (cache)
# WHY: 'smart' caches facts, speeding up repeated runs
gathering = smart

# FACT CACHING
# ------------
# WHAT: How long to cache gathered facts (in seconds)
# WHY: 86400 = 24 hours - facts don't change often
# NOTE: Only matters when gathering = smart
fact_caching_timeout = 86400

# STDOUT CALLBACK
# ---------------
# WHAT: How Ansible displays output
# WHY: 'yaml' format is more readable than default 'skippy'
# OPTIONS: yaml, json, debug, minimal, oneline
stdout_callback = yaml

# CALLBACKS ENABLED
# -----------------
# WHAT: Additional callback plugins to enable
# WHY: 'timer' shows how long each task takes - useful for optimization
callback_enabled = timer

# FORKS
# -----
# WHAT: How many parallel connections to make
# WHY: 10 is a good balance - higher = faster but more resource intensive
# NOTE: For Packer (single host), this doesn't matter much
forks = 10

# PIPELINING
# ----------
# WHAT: Reduces SSH operations by executing multiple commands in one session
# WHY: Significantly speeds up playbook execution
# REQUIREMENT: requiretty must be disabled in sudoers (Ubuntu default is fine)
pipelining = True

# ----------------------------------------------------------------------------
# [privilege_escalation] - How to become root
# ----------------------------------------------------------------------------
# This section controls sudo/become behavior
# ----------------------------------------------------------------------------
[privilege_escalation]

# BECOME
# ------
# WHAT: Whether to use privilege escalation (sudo) by default
# WHY: True because most tasks need root (installing packages, etc.)
become = True

# BECOME METHOD
# -------------
# WHAT: How to escalate privileges
# OPTIONS: sudo, su, pbrun, pfexec, doas, dzdo, ksu, runas
# WHY: sudo is standard on Ubuntu/most Linux systems
become_method = sudo

# BECOME USER
# -----------
# WHAT: Which user to become
# WHY: root for system administration tasks
become_user = root

# BECOME ASK PASS
# ---------------
# WHAT: Whether to prompt for sudo password
# WHY: False because EC2 instances use passwordless sudo
# NOTE: Ubuntu AMIs have NOPASSWD sudo configured by default
become_ask_pass = False

# ----------------------------------------------------------------------------
# [ssh_connection] - SSH-specific settings
# ----------------------------------------------------------------------------
# This section optimizes SSH connections for speed and reliability
# ----------------------------------------------------------------------------
[ssh_connection]

# SSH ARGS
# --------
# WHAT: Additional arguments passed to SSH
# WHY: These options speed up connections and handle common issues
#
# -o ControlMaster=auto     : Reuse SSH connections (faster)
# -o ControlPersist=60s     : Keep connection open for 60 seconds
# -o UserKnownHostsFile=/dev/null : Don't save host keys (for dynamic cloud IPs)
# -o StrictHostKeyChecking=no : Don't prompt for unknown hosts
#
ssh_args = -o ControlMaster=auto -o ControlPersist=60s -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no

# CONTROL PATH DIRECTORY
# ----------------------
# WHAT: Where to store SSH control sockets
# WHY: /tmp is fast and temporary - sockets don't need to persist
# NOTE: %(directory)s, %(hostname)s, %(port)s are replaced with actual values
control_path_dir = /tmp/ansible-ssh-%%h-%%p-%%r

# SCP IF SSH
# ----------
# WHAT: Use SCP instead of SFTP for file transfers
# WHY: smart = try SFTP first, fall back to SCP if needed
# NOTE: Some systems don't have SFTP enabled
scp_if_ssh = smart
